# Orb 'civisanalytics/civis-integrations-sdk-security-orb@dev:alpha' resolved to 'civisanalytics/civis-integrations-sdk-security-orb@dev:alpha'
# Orb 'circleci/orb-tools@10.0' resolved to 'circleci/orb-tools@10.0.3'
# Orb 'circleci/bats@1.0' resolved to 'circleci/bats@1.0.0'
# Orb 'circleci/shellcheck@2.0' resolved to 'circleci/shellcheck@2.0.0'
version: 2
jobs:
  orb-tools/lint:
    docker:
    - image: singapore/lint-condo
    resource_class: small
    steps:
    - run:
        command: |
          apk --update add git openssh
        name: Install Git and Openssh
    - checkout
    - run:
        command: |-
          touch .yamllint || true
          cat << EOF > .yamllint
          extends: relaxed

          rules:
              line-length:
                  max: 200
                  allow-non-breakable-inline-mappings: true

          EOF
        name: output default .yamllint file in the working directory
    - run:
        command: |
          yamllint .
        name: yamllint
  orb-tools/pack:
    docker:
    - image: circleci/circleci-cli:latest
    steps:
    - checkout
    - run:
        command: |
          mkdir -pv $(dirname orb.yml)
        name: Ensure destination path
    - run:
        command: |
          circleci orb pack --skip-update-check src > orb.yml
        name: Pack src to orb.yml
    - run:
        command: circleci orb --skip-update-check validate orb.yml
        name: Validate whether this is a well-formed orb.
    - persist_to_workspace:
        paths:
        - orb.yml
        root: .
    - store_artifacts:
        path: orb.yml
  shellcheck/check:
    docker:
    - image: koalaman/shellcheck-alpine:v0.7.1
    steps:
    - checkout
    - run:
        command: |2

          Set_SHELLCHECK_EXCLUDE_PARAM() {
              if [ -n "$SC_PARAM_EXCLUDE" ]; then
                  SHELLCHECK_EXCLUDE_PARAM="--exclude=$SC_PARAM_EXCLUDE "
              else
                  SHELLCHECK_EXCLUDE_PARAM=""
              fi
          }

          Check_for_shellcheck() {
              if ! command -v shellcheck &> /dev/null
              then
                  echo "Shellcheck not installed"
                  exit
              fi
          }

          Run_ShellCheck() {
              SC_PARAM_PATTERN="${SC_PARAM_PATTERN:-"*.sh"}"
              find "$SC_PARAM_DIR" ! -name "$(printf "*\n*")" -name "$SC_PARAM_PATTERN" > tmp
              set +e
              while IFS= read -r script
              do
                  # shellcheck disable=SC2086
                  shellcheck $SHELLCHECK_EXCLUDE_PARAM --shell=$SC_PARAM_SHELL --severity=$SC_PARAM_SEVERITY "$script" >> $SC_PARAM_OUTPUT
              done < tmp
              set -eo pipefail
          }

          Catch_SC_Errors() {
              if [ -s "$SC_PARAM_OUTPUT" ]; then
                  printf '\e[1;31mShellCheck Errors Found\e[0m\n'
                  cat "$SC_PARAM_OUTPUT"
                  exit 1
              else
                  printf '\e[1;32mNo ShellCheck Errors Found\e[0m\n'
              fi
          }

          SC_Main() {
              Check_for_shellcheck
              Set_SHELLCHECK_EXCLUDE_PARAM
              Run_ShellCheck
              Catch_SC_Errors
              rm tmp
          }


          # Will not run if sourced for bats.
          # View src/tests for more information.
          TEST_ENV="bats-core"
          if [ "${0#*$TEST_ENV}" == "$0" ]; then
              SC_Main
          fi
        environment:
          SC_PARAM_DIR: ./src/scripts
          SC_PARAM_EXCLUDE: SC2148
          SC_PARAM_OUTPUT: shellcheck.log
          SC_PARAM_PATTERN: ''
          SC_PARAM_SEVERITY: style
          SC_PARAM_SHELL: bash
        name: Run Shellcheck
    - store_artifacts:
        destination: shellcheck
        path: shellcheck.log
  bats/run:
    docker:
    - image: cimg/base:stable
    steps:
    - checkout
    - run:
        command: |
          checkRequirements() {
            if ! which git > /dev/null; then
                echo "git is required to install BATS"
                exit 1
            fi
            if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi
          }

          installBats() {
              cd /tmp
              git clone https://github.com/bats-core/bats-core.git
              cd /tmp/bats-core
              $SUDO ./install.sh /usr/local
          }


          checkInstall() {
              if ! which bats > /dev/null; then
                  echo "BATS has failed to install."
                  exit 1
              fi
              echo
              echo "BATS-Core installed"
              echo
          }

          runInstallBats() {
              checkRequirements
              installBats
              checkInstall
          }

          runInstallBats
        name: Install BATS-Core
    - run:
        command: bats ./src/tests
        name: Execute BATS tests
  orb-tools/publish-dev:
    docker:
    - image: circleci/circleci-cli:latest
    steps:
    - attach_workspace:
        at: workspace
    - run:
        command: "circleci orb publish --skip-update-check workspace/orb.yml civisanalytics/civis-integrations-sdk-security-orb@dev:alpha --token $CIRCLE_TOKEN \n"
        name: |
          Publish orb at workspace/orb.yml to civisanalytics/civis-integrations-sdk-security-orb@dev:alpha
    - run:
        command: "circleci orb publish --skip-update-check workspace/orb.yml civisanalytics/civis-integrations-sdk-security-orb@dev:${CIRCLE_SHA1:0:7} --token $CIRCLE_TOKEN \n"
        name: |
          Publish orb at workspace/orb.yml to civisanalytics/civis-integrations-sdk-security-orb@dev:${CIRCLE_SHA1:0:7}
    - store_artifacts:
        path: workspace/orb.yml
  trigger-integration-dev:
    docker:
    - image: cimg/base:edge
    steps:
    - checkout
    - run:
        command: |
          # Quietly try to make the install directory.
          mkdir -p ~/bin | true

          # Selectively export the SUDO command, depending if we have permission
          # for a directory and whether we're running alpine.
          if [[ $EUID == 0 ]]; then export SUDO=""; else # Check if we're root
            if cat /etc/issue | grep Alpine > /dev/null 2>&1 || ! [[ -w "~/bin" ]]; then
              export SUDO="sudo";
            fi
          fi

          # If our first mkdir didn't succeed, we needed to run as sudo.
          if [ ! -w ~/bin ]; then
            $SUDO mkdir -p ~/bin
          fi

          echo 'export PATH=$PATH:~/bin' >> $BASH_ENV
          source $BASH_ENV

          # check if jq needs to be installed
          if command -v jq >> /dev/null 2>&1; then

              echo "jq is already installed..."

            if [[ false == true ]]; then
              echo "removing it."
              $SUDO rm -f $(command -v jq)
            else
              echo "ignoring install request."
              exit 0
            fi
          fi

          # Set jq version
          if [[ latest == "latest" ]]; then
            JQ_VERSION=$(curl -Ls -o /dev/null -w %{url_effective} "https://github.com/stedolan/jq/releases/latest" | sed 's:.*/::')
            echo "Latest version of jq is $JQ_VERSION"
          else
            JQ_VERSION=latest
          fi

          # extract version number
          JQ_VERSION_NUMBER_STRING=$(echo $JQ_VERSION | sed -E 's/-/ /')
          arrJQ_VERSION_NUMBER=($JQ_VERSION_NUMBER_STRING)
          JQ_VERSION_NUMBER="${arrJQ_VERSION_NUMBER[1]}"

          # Set binary download URL for specified version
          # handle mac version
          if uname -a | grep Darwin > /dev/null 2>&1; then
            JQ_BINARY_URL="https://github.com/stedolan/jq/releases/download/${JQ_VERSION}/jq-osx-amd64"
          else
            # linux version
            JQ_BINARY_URL="https://github.com/stedolan/jq/releases/download/${JQ_VERSION}/jq-linux64"
          fi

          jqBinary="jq-$PLATFORM"

          if [ -d "$JQ_VERSION/sig" ]; then
            # import jq sigs

            if uname -a | grep Darwin > /dev/null 2>&1; then
              HOMEBREW_NO_AUTO_UPDATE=1 brew install gnupg coreutils

              PLATFORM=osx-amd64
            else
              if cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                $SUDO apk add gnupg > /dev/null 2>&1
              fi
              PLATFORM=linux64
            fi

            gpg --import "$JQ_VERSION/sig/jq-release.key" > /dev/null

            curl --output "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM" \
                --silent --show-error --location --fail --retry 3 \
                "$JQ_BINARY_URL"

            # verify sha256sum, sig, install

            gpg --verify "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM.asc"

            pushd "$JQ_VERSION/sig/v$JQ_VERSION_NUMBER" && grep "jq-$PLATFORM" "sha256sum.txt" | \
            sha256sum -c -
            popd
            jqBinary="$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM"

          else
            curl --output "$jqBinary" \
              --silent --show-error --location --fail --retry 3 \
              "$JQ_BINARY_URL"
          fi

          $SUDO mv "$jqBinary" ~/bin/jq
          $SUDO chmod +x ~/bin/jq

          # cleanup
          [[ -d "./$JQ_VERSION" ]] && rm -rf "./$JQ_VERSION"

          # verify version
          echo "jq has been installed to $(which jq)"
          echo "jq version:"
          echo "$(jq --version)"
        name: Install jq
        when: always
    - run:
        command: |-
          Setup() {
              VCS_TYPE=$(echo "${CIRCLE_BUILD_URL}" | cut -d '/' -f 4)
              T=$(eval echo "$TOKEN")
          }

          BuildParams() {
              PARAM_MAP=$(eval echo $PARAM_MAP)
              REQUEST_PARAMS='{\"branch\": \"$CIRCLE_BRANCH\", \"parameters\": $PARAM_MAP}'
              eval echo $REQUEST_PARAMS > pipelineparams.json
          }

          DoCurl() {
              curl -u "${T}": -X POST --header "Content-Type: application/json" -d @pipelineparams.json \
                "https://circleci.com/api/v2/project/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/pipeline" -o /tmp/curl-result.txt
          }

          Result() {
              CURL_RESULT=$(cat /tmp/curl-result.txt)
              if [[ $(echo "$CURL_RESULT" | jq -r .message) == "Not Found" || $(echo "$CURL_RESULT" | jq -r .message) == "Permission denied" || $(echo "$CURL_RESULT" | jq -r .message) == "Project not found" ]]; then
                  echo "Was unable to trigger integration test workflow. API response: $(cat /tmp/curl-result.txt | jq -r .message)"
                  exit 1
              else
                  echo "Pipeline triggered!"
                  echo "https://app.circleci.com/jobs/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/$(cat /tmp/curl-result.txt | jq -r .number)"
              fi
          }

          Main() {
              Setup
              BuildParams
              DoCurl
              Result
          }

          # Will not run if sourced for bats.
          # View src/tests for more information.
          TEST_ENV="bats-core"
          if [ "${0#*$TEST_ENV}" == "$0" ]; then
              Main
          fi
        environment:
          PARAM_MAP: '{\"run-integration-tests\": true, \"dev-orb-version\": \"dev:${CIRCLE_SHA1:0:7}\"}'
          TOKEN: $CIRCLE_TOKEN
        name: Trigger integration test workflow
workflows:
  test-pack:
    jobs:
    - orb-tools/lint
    - orb-tools/pack
    - shellcheck/check
    - bats/run
    - orb-tools/publish-dev:
        requires:
        - orb-tools/lint
        - orb-tools/pack
        - bats/run
        - shellcheck/check
        context: <publishing-context>
    - trigger-integration-dev:
        requires:
        - orb-tools/publish-dev
        context: <publishing-context>
  version: 2

# Original config.yml file:
# version: 2.1
# 
# orbs:
#   # Replace this with your own!
#   #<orb-name>: <namespace>/<orb-name>@<<pipeline.parameters.dev-orb-version>>
#   civis-integrations-sdk-security: civisanalytics/civis-integrations-sdk-security-orb@<<pipeline.parameters.dev-orb-version>>
#   orb-tools: circleci/orb-tools@10.0
#   bats: circleci/bats@1.0
#   shellcheck: circleci/shellcheck@2.0
# 
# # Pipeline Parameters
# ## These parameters are used internally by orb-tools. Skip to the Jobs section.
# parameters:
#   run-integration-tests:
#     description: An internal flag to prevent integration test from running before a development version has been created.
#     type: boolean
#     default: false
#   dev-orb-version:
#     description: >
#       The development version of the orb to test.
#       This value is automatically adjusted by the \"trigger-integration-tests-workflow\" job to correspond with the specific version created by the commit and should not be edited.
#       A \"dev:alpha\" version must exist for the initial pipeline run.
#     type: string
#     default: \"dev:alpha\"
# 
# jobs:
#   # Define one or more jobs which will utilize your orb's commands and parameters to validate your changes.
#   integration-test-1:
#     docker:
#       - image: cimg/base:stable
#     steps:
#       - checkout
#       # \"greet\" is a sample command packaged with this orb config.
#       # This sample integration test will run as long as the greet command exists. Once you remove the greet command you should remove this line.
#       # Push new changes first, before adding new tests to your config.
#       #- <orb-name>/greet
#       #- civis-integrations-sdk-security/greet
# 
# workflows:
#   # Prior to producing a development orb (which requires credentials) basic validation, linting, and even unit testing can be performed.
#   # This workflow will run on every commit
#   test-pack:
#     unless: << pipeline.parameters.run-integration-tests >>
#     jobs:
#       - orb-tools/lint # Lint Yaml files
#       - orb-tools/pack # Pack orb source
#       - shellcheck/check:
#           dir: ./src/scripts
#           exclude: SC2148
#       # optional: Run BATS tests against your scripts
#       - bats/run:
#           path: ./src/tests
#       # Publish development version(s) of the orb.
#       - orb-tools/publish-dev:
#           #orb-name: <namespace>/<orb-name>
#           orb-name: civisanalytics/civis-integrations-sdk-security-orb
#           context: <publishing-context> # A restricted context containing your private publishing credentials. Will only execute if approved by an authorized user.
#           requires:
#             - orb-tools/lint
#             - orb-tools/pack
#             - bats/run
#             - shellcheck/check
#       # Trigger an integration workflow to test the
#       # dev:${CIRCLE_SHA1:0:7} version of your orb
#       - orb-tools/trigger-integration-tests-workflow:
#           name: trigger-integration-dev
#           context: <publishing-context>
#           requires:
#             - orb-tools/publish-dev
# 
#   # This `integration-test_deploy` workflow will only run
#   # when the run-integration-tests pipeline parameter is set to true.
#   # It is meant to be triggered by the \"trigger-integration-tests-workflow\"
#   # job, and run tests on <your orb>@dev:${CIRCLE_SHA1:0:7}.
#   integration-test_deploy:
#     when: << pipeline.parameters.run-integration-tests >>
#     jobs:
#       # Run any integration tests defined within the `jobs` key.
#       - integration-test-1
#       # Publish a semver version of the orb. relies on
#       # the commit subject containing the text \"[semver:patch|minor|major|skip]\"
#       # as that will determine whether a patch, minor or major
#       # version will be published or if publishing should
#       # be skipped.
#       # e.g. [semver:patch] will cause a patch version to be published.
#       - orb-tools/dev-promote-prod-from-commit-subject:
#           #orb-name: <namespace>/<orb-name>
#           orb-name: civisanalytics/civis-integrations-sdk-security-orb
#           context: <publishing-context>
#           add-pr-comment: false
#           fail-if-semver-not-indicated: true
#           publish-version-tag: false
#           requires:
#             - integration-test-1
#           filters:
#             branches:
#               only:
#                 - master
#                 - main